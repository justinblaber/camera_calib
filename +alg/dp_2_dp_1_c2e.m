function jacob = dp_2_dp_1_c2e(p_1s, H_12, r_1)
    % This will compute the jacobian of the points in perspective "2",
    % which are centers of ellipses, with respect points in
    % perspective "1", which are centers of circles.
    %
    % Inputs:
    %   p_1s - array; Nx2 array of points in perspective "1"; centers of
    %       circles
    %   H_12 - array; 3x3 homography which transforms the points from
    %       perspective "1" to "2".
    %   r_1 - scalar; radius of circle in perspective "1"
    %
    % Outputs:
    %   jacob - array; 2*Nx2*N array.
    %       Format of jacobian is:
    %
    %               dx_1_1 dy_1_1 ... dx_1_N dy_1_N
    %       dx_2_1
    %       dy_2_1
    %          .
    %          .
    %          .
    %       dx_2_N
    %       dy_2_N

    % Compute jacobian
    u_prime = -H_12(3, 1)*((p_1s(:, 1)*H_12(1, 3))/r_1^2 + (H_12(1, 1)*(p_1s(:, 1).^2 - r_1^2))/r_1^2 + (p_1s(:, 1)*H_12(1, 2).*p_1s(:, 2))/r_1^2) - H_12(3, 2)*((H_12(1, 3)*p_1s(:, 2))/r_1^2 + (H_12(1, 2)*(p_1s(:, 2).^2 - r_1^2))/r_1^2 + (p_1s(:, 1)*H_12(1, 1).*p_1s(:, 2))/r_1^2) - H_12(3, 3)*(H_12(1, 3)/r_1^2 + (p_1s(:, 1)*H_12(1, 1))/r_1^2 + (H_12(1, 2)*p_1s(:, 2))/r_1^2);
    v_prime = -H_12(3, 1)*((p_1s(:, 1)*H_12(2, 3))/r_1^2 + (H_12(2, 1)*(p_1s(:, 1).^2 - r_1^2))/r_1^2 + (p_1s(:, 1)*H_12(2, 2).*p_1s(:, 2))/r_1^2) - H_12(3, 2)*((H_12(2, 3)*p_1s(:, 2))/r_1^2 + (H_12(2, 2)*(p_1s(:, 2).^2 - r_1^2))/r_1^2 + (p_1s(:, 1)*H_12(2, 1).*p_1s(:, 2))/r_1^2) - H_12(3, 3)*(H_12(2, 3)/r_1^2 + (p_1s(:, 1)*H_12(2, 1))/r_1^2 + (H_12(2, 2)*p_1s(:, 2))/r_1^2);
    w_prime = -H_12(3, 1)*((p_1s(:, 1)*H_12(3, 3))/r_1^2 + (H_12(3, 1)*(p_1s(:, 1).^2 - r_1^2))/r_1^2 + (p_1s(:, 1)*H_12(3, 2).*p_1s(:, 2))/r_1^2) - H_12(3, 2)*((H_12(3, 3)*p_1s(:, 2))/r_1^2 + (H_12(3, 2)*(p_1s(:, 2).^2 - r_1^2))/r_1^2 + (p_1s(:, 1)*H_12(3, 1).*p_1s(:, 2))/r_1^2) - H_12(3, 3)*(H_12(3, 3)/r_1^2 + (p_1s(:, 1)*H_12(3, 1))/r_1^2 + (H_12(3, 2)*p_1s(:, 2))/r_1^2);

    dx_2_dx_1 = (u_prime.*(H_12(3, 1)*(H_12(3, 3)/r_1^2 + (2*H_12(3, 1)*p_1s(:, 1))/r_1^2 + (H_12(3, 2)*p_1s(:, 2))/r_1^2) + (H_12(3, 1)*H_12(3, 3))/r_1^2 + (H_12(3, 1)*H_12(3, 2)*p_1s(:, 2))/r_1^2))./w_prime.^2 - (H_12(3, 1)*(H_12(1, 3)/r_1^2 + (2*H_12(1, 1)*p_1s(:, 1))/r_1^2 + (H_12(1, 2)*p_1s(:, 2))/r_1^2) + (H_12(1, 1)*H_12(3, 3))/r_1^2 + (H_12(1, 1)*H_12(3, 2)*p_1s(:, 2))/r_1^2)./w_prime;
    dx_2_dy_1 = (u_prime.*(H_12(3, 2)*(H_12(3, 3)/r_1^2 + (H_12(3, 1)*p_1s(:, 1))/r_1^2 + (2*H_12(3, 2)*p_1s(:, 2))/r_1^2) + (H_12(3, 2)*H_12(3, 3))/r_1^2 + (H_12(3, 1)*H_12(3, 2)*p_1s(:, 1))/r_1^2))./w_prime.^2 - (H_12(3, 2)*(H_12(1, 3)/r_1^2 + (H_12(1, 1)*p_1s(:, 1))/r_1^2 + (2*H_12(1, 2)*p_1s(:, 2))/r_1^2) + (H_12(1, 2)*H_12(3, 3))/r_1^2 + (H_12(1, 2)*H_12(3, 1)*p_1s(:, 1))/r_1^2)./w_prime;
    dy_2_dx_1 = (v_prime.*(H_12(3, 1)*(H_12(3, 3)/r_1^2 + (2*H_12(3, 1)*p_1s(:, 1))/r_1^2 + (H_12(3, 2)*p_1s(:, 2))/r_1^2) + (H_12(3, 1)*H_12(3, 3))/r_1^2 + (H_12(3, 1)*H_12(3, 2)*p_1s(:, 2))/r_1^2))./w_prime.^2 - (H_12(3, 1)*(H_12(2, 3)/r_1^2 + (2*H_12(2, 1)*p_1s(:, 1))/r_1^2 + (H_12(2, 2)*p_1s(:, 2))/r_1^2) + (H_12(2, 1)*H_12(3, 3))/r_1^2 + (H_12(2, 1)*H_12(3, 2)*p_1s(:, 2))/r_1^2)./w_prime;
    dy_2_dy_1 = (v_prime.*(H_12(3, 2)*(H_12(3, 3)/r_1^2 + (H_12(3, 1)*p_1s(:, 1))/r_1^2 + (2*H_12(3, 2)*p_1s(:, 2))/r_1^2) + (H_12(3, 2)*H_12(3, 3))/r_1^2 + (H_12(3, 1)*H_12(3, 2)*p_1s(:, 1))/r_1^2))./w_prime.^2 - (H_12(3, 2)*(H_12(2, 3)/r_1^2 + (H_12(2, 1)*p_1s(:, 1))/r_1^2 + (2*H_12(2, 2)*p_1s(:, 2))/r_1^2) + (H_12(2, 2)*H_12(3, 3))/r_1^2 + (H_12(2, 2)*H_12(3, 1)*p_1s(:, 1))/r_1^2)./w_prime;

    dp_2_dx_1 = reshape([dx_2_dx_1 dy_2_dx_1]', [], 1);
    dp_2_dy_1 = reshape([dx_2_dy_1 dy_2_dy_1]', [], 1);

    % TODO: find a better way to construct sparse diagonal jacobian,
    % as this is probably a bottleneck

    jacob_cell = mat2cell(sparse([dp_2_dx_1 dp_2_dy_1]), 2*ones(1, size(p_1s, 1)), 2);
    jacob = blkdiag(jacob_cell{:});
end
